# w1113

最典型的 Monte Carlo：**用随机点的比例来估计面积 / 概率 / 积分**。

**Definition**

> Monte Carlo methods approximate expectations, probabilities, or integrals by **random sampling** and using the **sample average** as an estimator.

**Mathematical basis**

> The method relies on the **Law of Large Numbers** and often the **Central Limit Theorem**, so the Monte Carlo estimator converges to the true value and its error decreases at rate O(1/N)O(1/\sqrt{N})O(1/N).

**Typical use**

> It is widely used for **numerical integration**, **simulation of complex systems**, **uncertainty quantification**, and **Bayesian inference** (e.g. MCMC).

## Week 11 – Monte Carlo integration & stock option simulation

### 1. 加载常用包

```
## Week 11 常用包 -------------------------------------------------

library(tidyverse)  # 数据处理与可视化一条龙
library(ggplot2)    # 画图
library(ggthemes)   # ggplot 主题
library(here)       # 管理文件路径（可选）
```

------

### 2. Monte Carlo 估计定积分 + integrate() 对比

目标：
 在区间 [0,3][0,3][0,3] 上，对
 g(x)=x3sin⁡(x+3.42)g(x) = x^3 \sin\left(\frac{x + 3.4}{2}\right)g(x)=x3sin(2x+3.4​)
 做积分，分别用：

- **Monte Carlo 积分**（随机点平均 × 区间长度）
- R 内置的 `integrate()` 精确数值积分

#### 2.1 定义被积函数并画出曲线

```
## 定义被积函数 g(x)
s <- function(x) { 
  x^3 * sin((x + 3.4) / 2) 
}

## 画出在 [0,3] 上的函数曲线，辅助理解
x.plot <- seq(0, 3, length.out = 1000)  # 在 [0,3] 上取很多点
y.plot <- s(x.plot)

plot(x.plot, y.plot, type = "l",
     xlab = "x", ylab = "g(x)",
     main = "g(x) = x^3 * sin((x+3.4)/2)")
abline(h = 0, col = "grey")
```

#### 2.2 Monte Carlo 积分估计

```
set.seed(5003)  # 固定随机种子，结果可复现

## 1. 在区间 [0,3] 上均匀抽样 n 个点
n <- 50000
x <- runif(n, min = 0, max = 3)  # 在 [0,3] 上均匀随机

## 2. 计算对应的函数值
gx <- s(x)

## 3. Monte Carlo 积分估计：
##    积分 ≈ 区间长度 * 平均函数值
interval.length <- 3 - 0
mc.integral <- interval.length * mean(gx)
mc.integral
```

#### 2.3 用 `integrate()` 做“精确”数值积分并对比

```
## 用 integrate() 得到数值积分的“真值”
true.integral <- integrate(s, lower = 0, upper = 3)
true.integral$value   # 积分估计值
true.integral$abs.error  # 数值误差估计

## 比较 Monte Carlo 与 integrate()
mc.integral
true.integral$value
mc.error <- mc.integral - true.integral$value
mc.error
```

> 复习要点（概念）：
>
> - Monte Carlo 积分思想：**随机点平均 × 区间长度**
> - 随机点越多 nnn 越大，估计越稳定（方差约 σ2/n\sigma^2/nσ2/n）
> - `integrate()` 是确定性数值积分算法，用自适应高精度方法；MC 是随机模拟法

------

### 3. 用几何布朗运动（GBM）模拟股票价格

目标：
 用讲义中的 GBM 模型：

dS=S(μdT+σdTN)dS = S(\mu dT + \sigma \sqrt{dT} \mathcal{N})dS=S(μdT+σdTN)

离散化为：

St+1=St⋅exp⁡((μ−12σ2)Δt+σΔtZt)S_{t+1} = S_t \cdot \exp\Big( (\mu - \frac{1}{2}\sigma^2)\Delta t + \sigma \sqrt{\Delta t} Z_t \Big)St+1=St⋅exp((μ−21σ2)Δt+σΔtZt)

或类似形式，用 `rnorm()` 生成正态随机数，模拟若干天的股票路径。

#### 3.1 定义股票路径模拟函数

```
set.seed(5003)

## 使用几何布朗运动模拟股票价格路径
## ndays : 模拟天数
## S0    : 初始股价
## mu    : 漂移（年化期望收益率）
## sigma : 波动率（年化标准差）
stock.sim <- function(ndays, S0, mu, sigma) {
  dt <- 1 / 365              # 时间步长：按“每天”离散
  S  <- numeric(ndays + 1)   # 存储每一天价格
  S[1] <- S0                 # 初始价格

  for (t in 1:ndays) {
    # 生成当天的标准正态随机数 Z_t
    Z <- rnorm(1, mean = 0, sd = 1)
    
    # 经典 GBM 离散形式（对数量级/连续时间合理）：
    S[t + 1] <- S[t] * exp((mu - 0.5 * sigma^2) * dt + sigma * sqrt(dt) * Z)
    
    ## 课程中也可能用更简单的近似：
    ## S[t + 1] <- S[t] * (1 + mu * dt + sigma * sqrt(dt) * Z)
    ## 两种形式思想相同：确定性 + 随机波动
  }
  return(S)
}
```

#### 3.2 在不同波动率 σ\sigmaσ 下模拟多条路径并画图

```
## 模拟参数
ndays <- 90    # 模拟 90 天
S0    <- 100   # 初始股价 100
mu    <- 0.05  # 年化 5% 收益
sigmas <- c(0.1, 0.25, 0.5, 0.75, 1)  # 不同波动率

## 生成数据框以便 ggplot 画多条线
sim.list <- lapply(sigmas, function(sig) {
  S.path <- stock.sim(ndays = ndays, S0 = S0, mu = mu, sigma = sig)
  tibble(
    day = 0:ndays,
    price = S.path,
    sigma = paste0("sigma = ", sig)
  )
})

sim.df <- bind_rows(sim.list)

## 画图：不同波动率下的 5 条价格路径
ggplot(sim.df, aes(x = day, y = price, colour = sigma)) +
  geom_line(linewidth = 0.9) +
  labs(title = "Simulated stock prices via GBM",
       x = "Day", y = "Price") +
  theme_minimal()
```

> 复习要点：
>
> - `rnorm()` 生成标准正态噪声，代表随机冲击
> - `dt = 1/365`：按天离散化
> - 波动率越大，路径抖动越厉害
> - 可扩展到“期权定价”：在终止日用 payoff 函数（如 max(S_T - K, 0)）对模拟结果取平均再折现

------

## Week 13 – MCMC & Metropolis–Hastings

Week 13 的 workshop 主要是 **MCMC / Metropolis–Hastings 算法**，内容比前面稍抽象，但 R 代码其实很固定：
 **（1）写出目标分布的似然或密度；（2）写 MH 循环；（3）丢弃 burn-in，剩下的样本做估计。**

### 1. Metropolis–Hastings for coin toss parameter θ

假设：

- 我们有一串硬币抛掷数据 `coin.flips`（0/1），
- 想估计“正面概率” θ\thetaθ，
- 用 MH 构造 θ\thetaθ 的 Markov 链，并用后验均值等来估计。

#### 1.1 定义似然函数（以 log-likelihood 形式）

（原 HTML 里是类似的结构；下面是合理的复现）

```
## coin.flips: 一个 0/1 向量，如 c(1,0,1,1,...)
## theta: 正面概率
## 返回 log-likelihood，数值更稳定
likelihood <- function(theta, coin.flips) {
  if (theta <= 0 || theta >= 1) return(-Inf)  # theta 必须在 (0,1) 内
  sum(coin.flips * log(theta) + (1 - coin.flips) * log(1 - theta))
}
```

#### 1.2 Metropolis–Hastings 主循环

```
set.seed(5003)

## MCMC 参数
niters <- 1000          # 迭代次数（链长度）
curr.theta <- 0.5       # 当前参数初始值
theta.chain <- numeric(niters + 1)  # 用来存储 θ 的轨迹
theta.chain[1] <- curr.theta

## 假设已经有 coin.flips 数据:
## coin.flips <- c(1, 0, 1, 1, 0, ...)

for (i in 1:niters) {
  ## 1. 提议新值：用一个简单的随机游走 proposal
  proposal.theta <- curr.theta + rnorm(1, mean = 0, sd = 0.05)
  
  ## 2. 如果提议落在 [0,1] 外，直接拒绝
  if (proposal.theta < 0 || proposal.theta > 1) {
    theta.chain[i + 1] <- curr.theta
    next
  }
  
  ## 3. 计算当前值与候选值的 log-likelihood
  curr.log.likeli     <- likelihood(curr.theta, coin.flips)
  proposal.log.likeli <- likelihood(proposal.theta, coin.flips)
  
  ## 4. 接受概率 alpha = min(1, exp(logL_prop - logL_curr))
  alpha <- min(exp(proposal.log.likeli - curr.log.likeli), 1)
  
  ## 5. 以 alpha 概率接受新值
  if (runif(1) < alpha) {
    curr.theta <- proposal.theta
  }
  
  ## 6. 记录链的当前状态
  theta.chain[i + 1] <- curr.theta
}
```

#### 1.3 丢弃 burn-in，计算后验均值和后验标准差

```
## 丢掉前 100 次迭代作为 burn-in
burn_in <- 100
theta.post <- theta.chain[(burn_in + 1):(niters + 1)]

## 用链的后半部分估计 theta 的“后验均值”和“后验标准差”
mean(theta.post)  # 类似于 bayesian estimator
sd(theta.post)

## 画出链的轨迹，检查是否像一只“毛毛虫”（已收敛）
plot(theta.post, type = "l",
     xlab = "Iteration (post burn-in)", ylab = expression(theta),
     main = "MCMC trace plot of theta")
abline(h = mean(theta.post), col = "red")
```

> 复习要点：
>
> - `likelihood()` 返回 **log-likelihood**，数值更稳定
> - MH 核心公式：
>    α=min⁡(1,π(θ′)q(θ∣θ′)π(θ)q(θ′∣θ))\alpha = \min\left(1, \frac{\pi(\theta') q(\theta \mid \theta')}{\pi(\theta) q(\theta' \mid \theta)}\right)α=min(1,π(θ)q(θ′∣θ)π(θ′)q(θ∣θ′)​)
>    对称 proposal（如 N(curr, σ²)）时 q(⋅)q(\cdot)q(⋅) 抵消 → 只需要 `exp(logL' - logL)`
> - 链看起来像“毛毛虫”并在一个范围内上下波动，说明大致收敛

------

### 2. 一般化的 Metropolis–Hastings 算法函数（抽象版）

原 workshop 给了一个抽象形式的 MH “算法函数”，利用给定的目标密度 `f()` 和 proposal `q()`，生成样本。

```
## 假设已经有：
## f(x):   目标密度（只要比例正确即可，不要求归一化）
## q(x, sigma): 给定当前 x，用某种方式生成 proposal 值的函数

algorithm <- function(x_0, n, sigma) {
  x <- numeric(n)    # 存储链
  x[1] <- x_0        # 初始值
  
  for (i in 1:(n - 1)) {
    ## 1. 生成 proposal
    prop.x <- q(x[i], sigma = sigma)
    
    ## 2. 计算接受概率（假设对称 proposal，简化成 f(prop)/f(curr)）
    alpha <- min(f(prop.x) / f(x[i]), 1)
    
    ## 3. 以 alpha 概率接受 proposal
    if (runif(1) < alpha) {
      x[i + 1] <- prop.x
    } else {
      x[i + 1] <- x[i]
    }
  }
  
  return(x)
}
```

> 复习要点：
>
> - 这个 `algorithm()` 是 **通用 MH 模板**：
>   1. 给初值 `x_0`
>   2. 给目标密度 `f`
>   3. 给 proposal 生成函数 `q`
>   4. 就能生成一条样本链 `x`
> - 考试中如果要你“写出 MCMC 算法伪代码/代码”，基本就是这种模式